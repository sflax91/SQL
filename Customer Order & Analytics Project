#Project completed in SQLiteStudio, using BIT_DB database downloaded from here:
#https://www.dropbox.com/s/cvsasmtr8syq2c2/BIT_DB?dl=0 as part of Break Into Tech online course

#Database contains six tables: JanSales, FebSales, MarSales, AprSales, MaySales, and customers.
#customers table contains two attributes: order_id and acctnum
#check data types on order_id and acctnum:
  PRAGMA table_info(customers)
  
#order_id is varchar(8) and acctnum is varchar(10)

#repeat process for other tables, confirm that types make sense for the info in the attributes (ex: datetime is the datatype for the orderdate atribute)

_________________________
#First question: How many orders were placed in January?
#Before we begin, we need to check for clean data. A quick look (SELECT * FROM BIT_DB.JanSales) at our JanSales table, sorted by orderID ASC and DESC (by double clicking orderID column in results), 
shows that majority of orderIDs are 6-digit numbers, but others have the text "Order ID" and others are blank. We'll want to filter these out by attaching
  WHERE length(orderid) = 6
  AND orderid <> 'Order ID'
to our queries.

#Next, I want to check for duplicates. Duplicates might give us an incorrect number when searching for total orders placed in January. Using the following query:
  SELECT 
      orderID,
      product,
      location,
      quantity,
      orderdate,
      COUNT(*)
  FROM 
      BIT_DB.JanSales
  WHERE 
    length(orderid) = 6
  AND 
    orderid <> 'Order ID'
  GROUP BY
      orderID,
      product,
      location,
      quantity,
      orderdate
  HAVING 
    COUNT(*) > 1

#I found 10 instances where a row was repeated: same exact order time, quantity, product, etc. 
Running an abridged version of the above query (only selecting OrderID), I can see that OrderIDs can be repeated, but often have different products for the same order. 
And we know that more than 1 quantity of an item can be purchased (SELECT DISTINCT(quantity)FROM BIT_DB.JanSales). 
So, it could be fair to assume that these initial duplicates are errors, since instead of ordering the exact same item twice, one could order a quantity of 2. 
But, without understanding how these items were ordered (online shopping?), we can't immediately exclude these duplicates since we're not absolutely sure they're errors.
In fact, there's one other possibility: an order # could be shared by multiple accounts. Taking a random order ID from the above results, we can join with the customers table:
  SELECT 
      acctnum,
      orderID,
      product,
      location,
      quantity,
      orderdate
  FROM 
      BIT_DB.JanSales jan
  INNER JOIN
      BIT_DB.customers cust
  ON
      cust.order_ID = jan.orderID
  WHERE 
    length(orderid) = 6
  AND 
    orderid <> 'Order ID'
  AND 
    orderID = 141365
  GROUP BY
      acctnum
  HAVING 
    COUNT(*) > 1 

#And lo and behold, 
acctnum   orderID product         location                                quantity  orderdate
77371355	141365	Vareebadd Phone	20 Dogwood St, New York City, NY 10001	1	        01/10/19 11:19
90935286	141365	Vareebadd Phone	20 Dogwood St, New York City, NY 10001	1	        01/10/19 11:19

#Two separate account numbers with the same orderID, product ordered, location, and order date and time. 
In a normal business setting this would be a cause for concern, where I'd bring this to supervisors and try to get more clarity on the data,
as it would be highly unusual for two separate accounts to have all other details be similar (unless it were a common occurance for roommates/
significant others to click "buy" on the same item at the exact same time). However, this dataset being from a certificate course, it's likely
that a lot of this data was randomly generated and re-used details over and over again, and my requests for clarity went unacknowledged. 
So, we'll continue on as if these are separate, unrelated orders.

#All that being said, the query
  SELECT
    Count(*)
  FROM
    BIT_DB.JanSales
  WHERE
    length(orderid) = 6
  AND 
    orderid <> 'Order ID'
#gives us the answer of 9,681 orders in January

_________________________
#Second question: How many of those orders were for an iPhone?
#We'll begin by examining the "products" category:
  SELECT
      DISTINCT(product)
  FROM
      BIT_DB.JanSales

#There's only one product listed as an "iPhone", so we won't need to group different iterations of iPhones (iPhone X, iPhone XR, etc) together. We can use a simple filter:
  SELECT
    Count(product)
  FROM
    BIT_DB.JanSales
  WHERE 
    product = 'iPhone'
  AND 
    length(orderid) = 6
  AND 
    orderid <> 'Order ID'

#379 orders were for an iPhone.

_________________________
#Third question: Select the customer account numbers for all the orders that were placed in February. 
#Since we're dealing with both account numbers, orders, and a specific month, we need to join two tables together. We don't care if they placed more than one order, so we'll want the distinct account numbers:
  SELECT
    DISTINCT(acctnum) accounts
  FROM
    BIT_DB.customers cust
  INNER JOIN
    BIT_DB.FebSales sales
  ON
    sales.orderID = cust.order_id
  WHERE 
    length(orderid) = 6
  AND 
    orderid <> 'Order ID'

#This gives us a list of 11,986 accounts that ordered in February.

_________________________
#Fourth question: Which product was the cheapest one sold in January, and what was the price? 
#We can do this a number of ways, and since I like practicing subqueries, we'll use one (probably needlessly complicated for the information we want).
#This is asking us two questions, which can each be represented by a query. First, what was the price of the cheapest product in January?
  SELECT
    min(price)
  FROM
    BIT_DB.JanSales

#The above query tells us that minimum price was $2.99. Now, we can wrap that in another query to tell us what product is associated with that price:
  SELECT
    DISTINCT(product),
    price
  FROM
    BIT_DB.JanSales
  WHERE
    price IN (
              SELECT
                min(price)
              FROM
                BIT_DB.JanSales
              )

#We find that the AAA Batteries (4-pack) was the product that cost $2.99.

_________________________
#Fifth question: What is the total revenue for each product sold in January?
#This one requires us to do some in-query calculations. In effect, we need the total amount of each product sold, multiplied by how much that product costs.
#In the query, we'd represent this as SUM(quantity)*price, and we'll group by the product:
  SELECT 
    product,
    SUM(quantity)*price as total_revenue
  FROM 
    BIT_DB.JanSales Jan 
  WHERE 
    length(orderid) = 6
  AND 
    orderid <> 'Order ID'
  GROUP BY
    product

#This gives us the list of all 19 products, with their total revenue in an adjacent column.

_________________________
#Sixth question: Which products were sold in February at 548 Lincoln St, Seattle, WA 98101, how many of each were sold, and what was the total revenue?
#This is essentially the previous question, with an additional filter (and a different month).
  SELECT
    product,
    quantity,
    price,
    SUM(quantity)*price as total_revenue,
    location
  FROM
    BIT_DB.FebSales
  WHERE 
    length(orderid) = 6
  AND 
    orderid <> 'Order ID'
  AND 
    location = '548 Lincoln St, Seattle, WA 98101'

#This address ordered 2 AA Batteries (4-pack), which cost a total of $7.68.

_________________________
#Seventh question: How many customers ordered more than 2 products at a time in February, and what was the average amount spent for those customers? 
#We can interpret this question in two ways. The first way would be to see which customers ordered the same product twice, separately but as part of the same order.
#These are basically the duplicates we checked for in the first question. We run the following query:
  SELECT 
    DISTINCT orderID,
    product,     
    location,
    quantity,
    orderdate,
    COUNT(*)
  FROM 
      BIT_DB.FebSales
  WHERE 
    length(orderid) = 6
  AND 
    orderid <> 'Order ID'
  GROUP BY
    orderID,
    product,
    location,
    quantity,
    orderdate
  HAVING 
    COUNT(*) > 1 
  ORDER BY
    orderID

#We find 18 duplicates. However, we know these duplicates are actually from separate accounts, based on what we learned in question 1. So, technically, they're separate customers.
Thus, we'll want to focus on orders where the quantity ordered is greater than 2. We'll still need to join the customers dataset with the FebSales dataset to get our answer.
Using the query
  SELECT 
    COUNT(DISTINCT cust.acctnum) num_of_cust, 
    AVG(quantity*price) average_price
  FROM 
    BIT_DB.FebSales feb
  LEFT JOIN 
    BIT_DB.customers cust
  ON 
    feb.orderid = cust.order_id
  WHERE 
    feb.Quantity > 2
  AND 
    length(orderid) = 6 
  AND 
    orderid <> 'Order ID'

#We learn that 278 customers ordered more than 2 products at a time in February, and they paid an average of $13.83.

_________________________
#Eighth question: List all the products sold in Los Angeles in February, and include how many of each were sold. 
#We need to tell SQL to look in the location field for the addresses that contain 'Los Angeles'. This is where the LIKE and % commands come in:
  SELECT
    product,
    SUM(quantity)
  FROM
    BIT_DB.FebSales
  WHERE
    location LIKE '%Los Angeles%'
  GROUP BY
    product

#This query produces a list of 19 products sold in February, with their total amount sold next to them.


